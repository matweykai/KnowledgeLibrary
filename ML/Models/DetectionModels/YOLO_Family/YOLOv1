YOLOv1 - это младшая модель из семейства YOLO

* Для своего времени обладала очень хорошей скоростью, но имела не очень высокое
  качество детекции

* В статье говорится о нарезании изображения на сетку SxS - это лишь абстракция
  представления выхода модели, которая используется для правильного 
  распределения меток при обучении

* Ячейка, в которую попадает центр объекта, ответственна за его предсказание.
  А при работе модели, выбор оптимальной рамки производится за счёт NMS

* Модель предсказывает значения x, y объекта относительно положения ячейки (от
  её левого верхнего угла), а ширину и высоту относительно всего изображения

Особенности обучения:
* Вводится понятие object confidence, которое при обучении вычисляется как:
	C = Pr(object) * IOU_truth_pred, где:

	Pr(object) - вероятность нахождения объекта(1 - если центр объекта в 
	данной ячейке и 0 в противном случае)

	IOU_thuth_pred - IOU между GT боксом и предсказанным

* Такой подход применяется, чтобы модель научилась сама предсказывать confidence
  score, а не ставила его 0 или 1 всегда

* При обучении используется интересная loss функция, которая описывает 
  регрессионные задачи:

	YOLO_loss = l_coord * sum(sum( 1_obj_i_j * ((x_i - x_i_pred)^2 + (y_i - y_i_pred)^2) ){j: 1 до B}) {i: 1 до S^2} +
		+ l_coord * sum(sum( 1_obj_i_j * ((sqrt(w_i) - sqrt(w_i_pred))^2 + (sqrt(h_i) - sqrt(h_i_pred))^2) )) {j: 1 до B} ) {i: 1 до S^2} +
		+ sum(sum(1_obj_i_j * (C_i - C_i_pred)^2 ) {j: 1 до B} ) {i: 1 до S^2} +
		+ l_no_obj * sum(sum(1_no_obj_i_j * (C_i - C_i_pred)^2 ) {j: 1 до B} ) {i: 1 до S^2} +
		+ sum(1_obj_i * sum( (p_i_j - p_i_j_pred)^2 ) {j: 1 до class_count} ) {i: 1 до S^2}

	l_coord - константный коэффициент для вычисления координат
	1_obj_i_j - это функция, которая равна 1, если ячейка i, j ответственна
		    за его предсказание и 0 в противном случае

* При вычислении loss функции из B предсказаний ответственным является то, у 
  которого IOU наибольшее

* Коэффициенты l_coord и l_no_obj нужны для исправления различных ограничений
  loss функции такого вида

* В слагаемом, которое отвечает за ширину и высоту используются корни, чтобы
  маленькие отклонения от метки для больших и маленьких объектов имело разный
  вес, тк маленькие отклонения в большом объекте не так критичны, как в 
  маленьком

Преимущества и недостатки:
 - Быстрая скорость работы ~45 FPS
 - Много False Negative ошибок, то есть много объектов она пропускает
 - Плохо справляется с объектами маленького размера
 - Является End-to-end trainable алгоритмом

Статьи:
 - https://arxiv.org/pdf/1506.02640.pdf
 - https://pyimagesearch.com/2022/04/11/understanding-a-real-time-object-detection-network-you-only-look-once-yolov1/
 - https://github.com/motokimura/yolo_v1_pytorch/blob/c3e60d7abdb6a36c472e4dae55ed696dfc08dd43/yolo_v1.py
